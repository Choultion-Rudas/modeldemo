<!DOCTYPE html>
<html lang="zh-CN">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>SenseVoice-Small</title>
	<link rel="preconnect" href="https://fonts.googleapis.com">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link href="https://fonts.googleapis.com/css2?family=Google+Sans+Text:wght@400;500;700&display=swap"
		rel="stylesheet">
	<link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
	<script type="module" src="https://unpkg.com/@material/web/all.js?module"></script>
	<style>
		:root {
			color-scheme: light;
			--md-sys-color-primary: #0b57d0;
			--md-sys-color-on-primary: #ffffff;
			--md-sys-color-primary-container: #d8e2ff;
			--md-sys-color-on-primary-container: #001947;
			--md-sys-color-secondary: #585e71;
			--md-sys-color-on-secondary: #ffffff;
			--md-sys-color-secondary-container: #dce2f9;
			--md-sys-color-on-secondary-container: #151b2c;
			--md-sys-color-error: #ba1a1a;
			--md-sys-color-on-error: #ffffff;
			--md-sys-color-background: #fdfbff;
			--md-sys-color-on-background: #1b1b1f;
			--md-sys-color-surface: #fdfbff;
			--md-sys-color-on-surface: #1b1b1f;
			--md-sys-color-surface-variant: #e1e2ec;
			--md-sys-color-on-surface-variant: #44474f;
			--md-sys-color-outline: #75777f;
			--md-sys-color-outline-variant: #c5c6d0;
			--md-sys-color-surface-container-lowest: #ffffff;
			--md-sys-color-inverse-surface: #2f3033;
			--md-sys-color-inverse-on-surface: #f2f0f4;
		}

		@media (prefers-color-scheme: dark) {
			:root {
				color-scheme: dark;
				--md-sys-color-primary: #a8c7fa;
				--md-sys-color-on-primary: #002d68;
				--md-sys-color-primary-container: #00428f;
				--md-sys-color-on-primary-container: #d8e2ff;
				--md-sys-color-secondary: #c0c6dd;
				--md-sys-color-on-secondary: #2a3042;
				--md-sys-color-secondary-container: #404659;
				--md-sys-color-on-secondary-container: #dce2f9;
				--md-sys-color-error: #ffb4ab;
				--md-sys-color-on-error: #690005;
				--md-sys-color-background: #1b1b1f;
				--md-sys-color-on-background: #e3e2e6;
				--md-sys-color-surface: #121418;
				--md-sys-color-on-surface: #e3e2e6;
				--md-sys-color-surface-variant: #44474f;
				--md-sys-color-on-surface-variant: #c5c6d0;
				--md-sys-color-outline: #8e9199;
				--md-sys-color-outline-variant: #44474f;
				--md-sys-color-surface-container-lowest: #0d0f13;
				--md-sys-color-inverse-surface: #e3e2e6;
				--md-sys-color-inverse-on-surface: #2f3033;
			}
		}

		body {
			font-family: 'Google Sans Text', sans-serif;
			background-color: var(--md-sys-color-background);
			color: var(--md-sys-color-on-surface);
			display: flex;
			justify-content: center;
			align-items: flex-start;
			padding: 1.5rem;
			min-height: 100vh;
			box-sizing: border-box;
			opacity: 0;
			transition: opacity 0.3s ease-in;
		}

		.card {
			max-width: 700px;
			width: 100%;
			background-color: var(--md-sys-color-surface);
			border-radius: 16px;
			padding: 24px;
		}

		.card.drag-over {
			outline: 2px dashed var(--md-sys-color-primary);
			outline-offset: -8px;
		}

		.material-icons,
		md-icon {
			font-feature-settings: 'liga';
		}

		md-filled-button,
		md-outlined-button {
			--md-filled-button-label-text-font: 'Google Sans Text';
			align-items: center;
		}

		.header {
			text-align: center;
			margin-bottom: 24px;
		}

		.header h1 {
			color: var(--md-sys-color-primary);
			font-size: 28px;
			font-weight: 700;
			margin: 0 0 12px 0;
		}

		.header p {
			margin: 4px 0;
			color: var(--md-sys-color-on-surface-variant);
		}

		.header .subtitle {
			font-size: .8rem;
			color: var(--md-sys-color-outline);
		}

		.form-group,
		.checkbox-group {
			margin-bottom: 20px;
		}

		.checkbox-group {
			display: flex;
			align-items: center;
			cursor: pointer;
			color: var(--md-sys-color-on-surface-variant);
		}

		md-checkbox {
			margin-right: 8px;
		}

		.file-upload-wrapper {
			display: flex;
			flex-direction: column;
			align-items: flex-start;
			gap: 8px;
		}

		.file-controls {
			display: flex;
			align-items: center;
			gap: 16px;
		}

		.drop-hint {
			display: none;
			font-size: .8rem;
			color: var(--md-sys-color-outline);
			margin: 0;
		}

		@media(pointer:fine) {
			.drop-hint {
				display: block;
			}
		}

		.slider-group label {
			color: var(--md-sys-color-on-surface-variant);
			font-size: .9rem;
			margin-bottom: 8px;
		}

		.button-wrapper {
			display: flex;
			justify-content: flex-end;
			align-items: center;
			gap: 16px;
			margin-top: 24px;
		}

		.progress-wrapper {
			margin-top: 16px;
			display: flex;
			flex-direction: column;
			gap: 8px;
		}

		md-linear-progress {
			width: 100%;
		}

		.result-wrapper {
			margin-top: 24px;
		}

		.result-header {
			display: flex;
			justify-content: space-between;
			align-items: center;
			gap: 16px;
			margin-bottom: 8px;
			flex-wrap: wrap;
		}

		#audio_input {
			display: none;
		}

		md-outlined-select {
			width: 100%;
		}

		md-outlined-text-field {
			width: 100%;
			--md-outlined-text-field-container-shape: 8px;
		}

		md-outlined-text-field textarea {
			resize: none;
			overflow-y: hidden;
		}

		details {
			border-top: 1px solid var(--md-sys-color-outline);
			margin-top: 24px;
			padding-top: 20px;
		}

		details>summary {
			cursor: pointer;
			font-weight: 500;
			font-size: 1rem;
			color: var(--md-sys-color-primary);
			list-style: none;
		}

		details>summary::-webkit-details-marker {
			display: none;
		}

		.details-content-wrapper {
			display: grid;
			grid-template-rows: 0fr;
			transition: grid-template-rows .3s ease-in-out;
		}

		details[open]>.details-content-wrapper {
			grid-template-rows: 1fr;
		}

		.advanced-settings-content {
			padding-top: 20px;
			overflow: hidden;
		}

		#toast {
			position: fixed;
			bottom: 2rem;
			left: 50%;
			transform: translateX(-50%);
			background-color: var(--md-sys-color-inverse-surface);
			color: var(--md-sys-color-inverse-on-surface);
			padding: 12px 18px;
			border-radius: 24px;
			font-size: 0.9rem;
			opacity: 0;
			visibility: hidden;
			transition: opacity 0.3s, visibility 0.3s;
			z-index: 1000;
		}

		#toast.show {
			opacity: 1;
			visibility: visible;
		}
	</style>
</head>

<body>
	<div class="card" id="drop-zone">
		<div class="header">
			<h1>SenseVoice-Small è¯­éŸ³è¯†åˆ«</h1>
			<p>SenseVoice æ˜¯å…·æœ‰éŸ³é¢‘ç†è§£èƒ½åŠ›çš„éŸ³é¢‘åŸºç¡€æ¨¡å‹ï¼ŒåŒ…æ‹¬è¯­éŸ³è¯†åˆ«ï¼ˆASRï¼‰ã€è¯­ç§è¯†åˆ«ï¼ˆLIDï¼‰ã€è¯­éŸ³æƒ…æ„Ÿè¯†åˆ«ï¼ˆSERï¼‰å’Œå£°å­¦äº‹ä»¶åˆ†ç±»ï¼ˆAECï¼‰æˆ–å£°å­¦äº‹ä»¶æ£€æµ‹ï¼ˆAEDï¼‰ã€‚</p>
			<p class="subtitle">æ”¯æŒ MP3, WAV, FLAC, M4A ç­‰å¸¸è§éŸ³é¢‘æ ¼å¼ã€‚</p>
		</div>

		<div class="form-group file-upload-wrapper">
			<div class="file-controls">
				<md-filled-button id="upload-button"><span class="material-icons"
						slot="icon">upload_file</span>ä¸Šä¼ éŸ³é¢‘</md-filled-button>
				<span id="file-name-label">å°šæœªé€‰æ‹©æ–‡ä»¶</span>
			</div>
			<p class="drop-hint">æˆ–æ‹–æ‹½æ–‡ä»¶è‡³æ­¤åŒºåŸŸ</p>
			<input type="file" id="audio_input" accept="audio/*">
		</div>

		<div class="form-group">
			<md-outlined-select id="language" label="æºè¯­è¨€">
				<md-select-option value="auto" selected>
					<div slot="headline">è‡ªåŠ¨æ£€æµ‹</div>
				</md-select-option>
				<md-select-option value="zh">
					<div slot="headline">ä¸­æ–‡</div>
				</md-select-option>
				<md-select-option value="en">
					<div slot="headline">English</div>
				</md-select-option>
				<md-select-option value="yue">
					<div slot="headline">ç²¤è¯­</div>
				</md-select-option>
				<md-select-option value="ja">
					<div slot="headline">æ—¥æœ¬èª</div>
				</md-select-option>
				<md-select-option value="ko">
					<div slot="headline">í•œêµ­ì–´</div>
				</md-select-option>
				<md-select-option value="nospeech">
					<div slot="headline">æ— è¯­éŸ³</div>
				</md-select-option>
			</md-outlined-select>
		</div>

		<details>
			<summary>é«˜çº§è®¾ç½®</summary>
			<div class="details-content-wrapper">
				<div class="advanced-settings-content">
					<div class="form-group slider-group">
						<label id="slider-label">æ–­å¥æœ€å¤§é•¿åº¦ï¼ˆç§’ï¼‰ï¼š15s</label>
						<md-slider id="merge_length" min="5" max="30" value="15" step="1" labeled></md-slider>
					</div>
					<label class="checkbox-group" for="use_itn"><md-checkbox id="use_itn"
							checked></md-checkbox>è‡ªåŠ¨æ·»åŠ æ ‡ç‚¹ä¸æ ¼å¼åŒ–</label>
					<label class="checkbox-group" for="merge_vad"><md-checkbox id="merge_vad"
							checked></md-checkbox>ä¼˜åŒ–é•¿éŸ³é¢‘æ–­å¥</label>
					<label class="checkbox-group" for="ban_emo_unk"><md-checkbox
							id="ban_emo_unk"></md-checkbox>å¼ºåˆ¶æƒ…æ„Ÿåˆ†ç±»</label>
				</div>
			</div>
		</details>

		<div class="button-wrapper">
			<p id="status-text"></p>
			<md-filled-button id="submit-button">
				<span class="material-icons" slot="icon" id="submit-icon">play_arrow</span>
				<span id="submit-text">å¼€å§‹è¯†åˆ«</span>
			</md-filled-button>
		</div>
		<div class="progress-wrapper" id="progress-wrapper" style="display: none;">
			<label id="progress-label">æ­£åœ¨ä¸Šä¼ ...</label>
			<md-linear-progress value="0" buffer="1" id="progress-bar"></md-linear-progress>
		</div>

		<div class="result-wrapper" id="result-wrapper" style="display: none;">
			<div class="result-header">
				<md-outlined-select id="result-format-select" label="æ˜¾ç¤ºæ ¼å¼" style="width: 160px;">
					<md-select-option value="çº¯å‡€æ–‡æœ¬" selected>
						<div slot="headline">çº¯å‡€æ–‡æœ¬</div>
					</md-select-option>
					<md-select-option value="åŸå§‹å¯Œæ–‡æœ¬">
						<div slot="headline">åŸå§‹å¯Œæ–‡æœ¬</div>
					</md-select-option>
					<md-select-option value="Emoji æ ¼å¼">
						<div slot="headline">Emoji æ ¼å¼</div>
					</md-select-option>
				</md-outlined-select>
				<div style="position: relative;">
					<md-filled-button id="copy-menu-button">
						<span class="material-icons" slot="icon">content_copy</span>å¤åˆ¶
					</md-filled-button>
					<md-menu id="copy-menu" anchor="copy-menu-button">
						<md-menu-item data-copy-format="çº¯å‡€æ–‡æœ¬">
							<div slot="headline">å¤åˆ¶çº¯å‡€æ–‡æœ¬</div>
						</md-menu-item>
						<md-menu-item data-copy-format="åŸå§‹å¯Œæ–‡æœ¬">
							<div slot="headline">å¤åˆ¶åŸå§‹å¯Œæ–‡æœ¬</div>
						</md-menu-item>
						<md-menu-item data-copy-format="Emoji æ ¼å¼">
							<div slot="headline">å¤åˆ¶ Emoji æ ¼å¼</div>
						</md-menu-item>
					</md-menu>
				</div>
			</div>
			<md-outlined-text-field id="result-text" type="textarea" rows="5" readonly></md-outlined-text-field>
		</div>
	</div>
	<div id="toast"></div>

	<script type="module">
		const D = document;
		const audioInput = D.getElementById('audio_input'), dropZone = D.getElementById('drop-zone'), fileNameLabel = D.getElementById('file-name-label'), submitButton = D.getElementById('submit-button'), submitIcon = D.getElementById('submit-icon'), submitText = D.getElementById('submit-text'), statusText = D.getElementById('status-text'), progressWrapper = D.getElementById('progress-wrapper'), progressLabel = D.getElementById('progress-label'), progressBar = D.getElementById('progress-bar'), resultWrapper = D.getElementById('result-wrapper'), resultFormatSelect = D.getElementById('result-format-select'), resultText = D.getElementById('result-text'), copyMenuButton = D.getElementById('copy-menu-button'), copyMenu = D.getElementById('copy-menu'), toast = D.getElementById('toast');
		const API_BASE = '/api', MAX_UPLOAD_SIZE = 100 * 1024 * 1024;
		let cachedFnIndex = null, rawRecognitionResult = '', etaInterval, isUploading = false;

		const emoji_dict_full = { "<|nospeech|><|Event_UNK|>": "â“", "<|zh|>": "", "<|en|>": "", "<|yue|>": "", "<|ja|>": "", "<|ko|>": "", "<|nospeech|>": "", "<|HAPPY|>": "ğŸ˜Š", "<|SAD|>": "ğŸ˜”", "<|ANGRY|>": "ğŸ˜¡", "<|NEUTRAL|>": "", "<|BGM|>": "ğŸ¼", "<|Speech|>": "", "<|Applause|>": "ğŸ‘", "<|Laughter|>": "ğŸ˜€", "<|FEARFUL|>": "ğŸ˜°", "<|DISGUSTED|>": "ğŸ¤¢", "<|SURPRISED|>": "ğŸ˜®", "<|Cry|>": "ğŸ˜­", "<|EMO_UNKNOWN|>": "", "<|Sneeze|>": "ğŸ¤§", "<|Breath|>": "", "<|Cough|>": "ğŸ˜·", "<|Sing|>": "", "<|Speech_Noise|>": "", "<|withitn|>": "", "<|woitn|>": "", "<|GBG|>": "", "<|Event_UNK|>": "" }, emo_dict_map = { "<|HAPPY|>": "ğŸ˜Š", "<|SAD|>": "ğŸ˜”", "<|ANGRY|>": "ğŸ˜¡", "<|NEUTRAL|>": "", "<|FEARFUL|>": "ğŸ˜°", "<|DISGUSTED|>": "ğŸ¤¢", "<|SURPRISED|>": "ğŸ˜®" }, event_dict = { "<|BGM|>": "ğŸ¼", "<|Speech|>": "", "<|Applause|>": "ğŸ‘", "<|Laughter|>": "ğŸ˜€", "<|Cry|>": "ğŸ˜­", "<|Sneeze|>": "ğŸ¤§", "<|Breath|>": "", "<|Cough|>": "ğŸ¤§" }, lang_dict = { "<|zh|>": "<|lang|>", "<|en|>": "<|lang|>", "<|yue|>": "<|lang|>", "<|ja|>": "<|lang|>", "<|ko|>": "<|lang|>", "<|nospeech|>": "<|lang|>" }, emo_set = new Set(["ğŸ˜Š", "ğŸ˜”", "ğŸ˜¡", "ğŸ˜°", "ğŸ¤¢", "ğŸ˜®"]), event_set = new Set(["ğŸ¼", "ğŸ‘", "ğŸ˜€", "ğŸ˜­", "ğŸ¤§", "ğŸ˜·"]);
		function format_str_v2(s) { let t = {}, e = "<|NEUTRAL|>"; for (const o in emoji_dict_full) t[o] = (s.match(new RegExp(o.replace(/\|/g, "\\|"), "g")) || []).length, s = s.replaceAll(o, ""); for (const o in emo_dict_map) (t[o] || 0) > (t[e] || 0) && (e = o); for (const o in event_dict) (t[o] || 0) > 0 && (s = event_dict[o] + s); s += emo_dict_map[e] || ""; const o = new Set([...emo_set, ...event_set]); return o.forEach(t => { s = s.replaceAll(" " + t, t).replaceAll(t + " ", t) }), s.trim() }
		function format_str_v3(s) { const t = t => t && emo_set.has(t.slice(-1)) ? t.slice(-1) : null, e = t => t && event_set.has(t[0]) ? t[0] : null; s = s.replaceAll("<|nospeech|><|Event_UNK|>", "â“"); for (const o in lang_dict) s = s.replaceAll(o, "<|lang|>"); let o = s.split("<|lang|>").map(t => format_str_v2(t).trim()), r = " " + (o[0] || ""); let n = e(r); for (let s = 1; s < o.length; s++) { if (!o[s]) continue; e(o[s]) === n && null !== n && (o[s] = o[s].substring(1)), n = e(o[s]), null !== t(o[s]) && t(o[s]) === t(r) && (r = r.slice(0, -1)), r += o[s].trim().replace(/^\s+/, "") } return r.trim() }
		function formatResult(t, e) { if (!t) return ""; return "çº¯å‡€æ–‡æœ¬" === e ? t.replace(/<\|[^>]*>/g, "").replace(/\s+/g, " ").trim() : "åŸå§‹å¯Œæ–‡æœ¬" === e ? t : "Emoji æ ¼å¼" === e ? format_str_v3(t) : t }
		function showToast(t) { toast.textContent = t, toast.classList.add("show"), setTimeout(() => { toast.classList.remove("show") }, 2e3) }
		function adjustTextareaHeight() { const t = resultText.shadowRoot.querySelector("textarea"); t && (t.style.height = "auto", t.style.height = t.scrollHeight + "px") }
		function updateResultDisplay() { if (rawRecognitionResult === null) return; resultText.value = formatResult(rawRecognitionResult, resultFormatSelect.value), adjustTextareaHeight() }
		function updateTimer(t, e) { clearInterval(etaInterval); const o = e ? "é¢„è®¡å‰©ä½™æ—¶é—´" : ""; if (!t || t <= 0) return void (statusText.textContent = o); let r = Math.round(t); statusText.textContent = `${o}: ${Math.floor(r / 60)}åˆ†${(r % 60).toString().padStart(2, "0")}ç§’`; etaInterval = setInterval(() => { r--, statusText.textContent = `${o}: ${Math.floor(r / 60)}åˆ†${(r % 60).toString().padStart(2, "0")}ç§’`, r <= 0 && (clearInterval(etaInterval), statusText.textContent = "æ­£åœ¨å¤„ç†...") }, 1e3) }
		async function getFnIndex(t = 0) { const e = 5, o = 5e3; if (null !== cachedFnIndex) return cachedFnIndex; if (statusText.textContent = 0 === t ? "æ­£åœ¨è¿æ¥æœåŠ¡å™¨..." : `æ­£åœ¨å”¤é†’æœåŠ¡å™¨... (å°è¯• ${t}/${e})`, t >= e) throw new Error("æœåŠ¡å™¨å”¤é†’å¤±è´¥ï¼Œè¯·ç¨ååˆ·æ–°é¡µé¢é‡è¯•ã€‚"); try { const t = new AbortController, r = setTimeout(() => t.abort(), 2e4), s = await fetch(`${API_BASE}/config`, { signal: t.signal }); if (clearTimeout(r), !s.ok) throw new Error(`Status ${s.status}`); const n = await s.json(); let l = n.dependencies.findIndex(t => "model_inference" === t.api_name); return cachedFnIndex = -1 !== l ? l : 0 } catch (r) { return await new Promise(t => setTimeout(t, o)), getFnIndex(t + 1) } }
		function genHash() { return Math.random().toString(36).slice(2) }
		function setSubmitButtonState(t) { const e = { idle: { text: "å¼€å§‹è¯†åˆ«", icon: "play_arrow", enabled: !0 }, uploading: { text: "æ­£åœ¨ä¸Šä¼ ", icon: "upload", enabled: !1 }, processing: { text: "æ­£åœ¨è¯†åˆ«", icon: "hourglass_empty", enabled: !1 }, disabled: { text: "å‡†å¤‡ä¸­...", icon: "pending", enabled: !1 } }; const o = e[t] || e.idle; submitText.textContent = o.text, submitIcon.textContent = o.icon, submitButton.disabled = !o.enabled }
		async function runViaQueue(t, e, o) { return new Promise((r, s) => { const n = new EventSource(`${API_BASE}/gradio_api/queue/data?session_hash=${o}`), a = setTimeout(() => { l || (n.close(), s(new Error("å¤„ç†è¶…æ—¶"))) }, 9e5); let l = !1; fetch(`${API_BASE}/gradio_api/queue/join`, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ data: [t, D.getElementById("language").value, "åŸå§‹å¯Œæ–‡æœ¬", D.getElementById("use_itn").checked, D.getElementById("merge_vad").checked, parseFloat(D.getElementById("merge_length").value), D.getElementById("ban_emo_unk").checked], fn_index: e, session_hash: o }) }).then(t => { if (!t.ok) throw new Error(`åŠ å…¥é˜Ÿåˆ—å¤±è´¥: ${t.status} ${t.statusText}`) }).catch(t => s(t)), n.onmessage = t => { try { const e = JSON.parse(t.data); if ("estimation" === e.msg) setSubmitButtonState("processing"), statusText.textContent = `æ’é˜Ÿä¸­ (ç¬¬ ${e.rank + 1} ä½)`, updateTimer(e.rank_eta, !0); else if ("process_starts" === e.msg) setSubmitButtonState("processing"), statusText.textContent = "", updateTimer(e.eta, !0); else if ("process_completed" === e.msg) l = !0, clearTimeout(a), n.close(), clearInterval(etaInterval), e.success ? r(e.output?.data?.[0] ?? "") : s(new Error(e.output?.error || "æœåŠ¡å™¨è¿”å›é”™è¯¯")); else if ("queue_full" === e.msg) l = !0, clearTimeout(a), n.close(), clearInterval(etaInterval), s(new Error("æœåŠ¡å™¨å½“å‰é˜Ÿåˆ—å·²æ»¡ï¼Œè¯·ç¨åå†è¯•ã€‚")) } catch (t) { } }, n.onerror = () => { l || (n.close(), clearInterval(etaInterval), s(new Error("è¿æ¥ä¸­æ–­"))) } }) }

		window.addEventListener('beforeunload', (e) => {
			if (isUploading) {
				e.preventDefault();
				e.returnValue = ''; // Required for Chrome
			}
		});

		D.addEventListener('DOMContentLoaded', () => {
			D.getElementById('upload-button').addEventListener('click', () => audioInput.click());
			audioInput.addEventListener('change', () => { if (audioInput.files.length > 0) fileNameLabel.textContent = audioInput.files[0].name });
			D.getElementById('merge_length').addEventListener('input', t => { D.getElementById('slider-label').textContent = `æ–­å¥æœ€å¤§é•¿åº¦ï¼ˆç§’ï¼‰ï¼š${t.target.value}s` });
			['dragenter', 'dragover', 'dragleave', 'drop'].forEach(t => dropZone.addEventListener(t, e => { e.preventDefault(), e.stopPropagation() }));
			['dragenter', 'dragover'].forEach(t => dropZone.addEventListener(t, () => dropZone.classList.add('drag-over')));
			['dragleave', 'drop'].forEach(t => dropZone.addEventListener(t, () => dropZone.classList.remove('drag-over')));
			dropZone.addEventListener('drop', t => { const e = t.dataTransfer.files; e.length > 0 && (audioInput.files = e, fileNameLabel.textContent = e[0].name) });
			resultFormatSelect.addEventListener('change', updateResultDisplay);
			copyMenuButton.addEventListener('click', () => copyMenu.open = !copyMenu.open);
			copyMenu.addEventListener('close', t => { const e = t.target.selected; if (!e || rawRecognitionResult === null) return; const o = e.dataset.copyFormat, r = formatResult(rawRecognitionResult, o); navigator.clipboard.writeText(r).then(() => showToast("å·²å¤åˆ¶åˆ°å‰ªè´´æ¿")).catch(t => { showToast("å¤åˆ¶å¤±è´¥"), console.error("Copy failed:", t) }) });

			submitButton.addEventListener('click', async () => {
				if (audioInput.files.length === 0) return showToast('è¯·é€‰æ‹©ä¸€ä¸ªéŸ³é¢‘æ–‡ä»¶ã€‚');
				const file = audioInput.files[0];
				if (file.size > MAX_UPLOAD_SIZE) return showToast(`æ–‡ä»¶è¿‡å¤§ï¼Œè¯·ä¸Šä¼ å°äº ${MAX_UPLOAD_SIZE / 1024 / 1024}MB çš„æ–‡ä»¶ã€‚`);

				setSubmitButtonState('disabled');
				statusText.textContent = ''; progressWrapper.style.display = 'none'; resultWrapper.style.display = 'none'; clearInterval(etaInterval);
				try {
					isUploading = true; // Set uploading flag
					const fnIndex = await getFnIndex(), sessionHash = genHash();
					setSubmitButtonState('uploading'); progressWrapper.style.display = 'flex'; progressLabel.textContent = 'æ­£åœ¨ä¸Šä¼ ...';
					const form = new FormData(); form.append('files', file);
					const xhr = new XMLHttpRequest(); xhr.open('POST', `${API_BASE}/gradio_api/upload?upload_id=${sessionHash}`, true);
					xhr.upload.onprogress = t => { t.lengthComputable && (progressBar.value = t.loaded / t.total, progressLabel.textContent = `æ­£åœ¨ä¸Šä¼ ... ${Math.round(t.loaded / t.total * 100)}%`) };
					const pathStr = await new Promise((resolve, reject) => {
						xhr.onload = () => xhr.status >= 200 && xhr.status < 300 ? resolve((t => { try { const e = JSON.parse(t), o = Array.isArray(e) ? e[0] : null; if (!o) throw new Error("Invalid response"); return "string" == typeof o ? o : o.path } catch (t) { throw new Error("Parse error") } })(xhr.responseText)) : reject(new Error(`ä¸Šä¼ å¤±è´¥: ${xhr.statusText || 'Status ' + xhr.status}`));
						xhr.onerror = () => reject(new Error('ç½‘ç»œé”™è¯¯'));
						xhr.send(form);
					});
					isUploading = false; // Unset uploading flag after upload is done

					progressWrapper.style.display = 'none'; setSubmitButtonState('processing'); statusText.textContent = 'å·²å…¥é˜Ÿï¼Œç­‰å¾…å¤„ç†...';
					const fileObj = { path: pathStr, url: null, size: file.size, orig_name: file.name, is_stream: false, meta: { _type: 'gradio.FileData' } };
					rawRecognitionResult = await runViaQueue(fileObj, fnIndex, sessionHash);
					statusText.textContent = 'è¯†åˆ«å®Œæˆï¼'; resultWrapper.style.display = 'block'; resultFormatSelect.value = 'çº¯å‡€æ–‡æœ¬'; updateResultDisplay();
				} catch (e) {
					statusText.textContent = `å¤±è´¥: ${e.message || 'æœªçŸ¥é”™è¯¯'}`; console.error(e);
				} finally {
					isUploading = false; // Ensure flag is always unset
					setSubmitButtonState('idle'); progressWrapper.style.display = 'none'; clearInterval(etaInterval);
				}
			});
			D.body.style.opacity = 1;
		});
	</script>
</body>

</html>